{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Textual Universal Directory Tree","text":"<p>A Textual plugin to make the DirectoryTree widget compatible with filesystems other than local.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install textual-universal-directorytree\n</code></pre>"},{"location":"#extra-dependencies","title":"Extra Dependencies","text":"<p>Some filesystems require additional dependencies to be installed. The <code>remote</code> extra includes all the known optional dependencies. See the Filesystems Supported section for more information.</p> <pre><code>pip install \"textual-universal-directorytree[remote]\"\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The below example shows how to use <code>textual-universal-directorytree</code> in a Textual app. It uses the GitHub filesystem to display the contents of the textual GitHub repository. It requires the <code>requests</code> library to be installed.</p> <pre><code>from rich.syntax import Syntax\nfrom textual import on\nfrom textual.app import App, ComposeResult\nfrom textual.containers import Horizontal, VerticalScroll\nfrom textual.widgets import Footer, Header, Static\nfrom textual_universal_directorytree import UniversalDirectoryTree\nclass UniversalDirectoryTreeApp(App):\n\"\"\"\n    The power of upath and fsspec in a Textual app\n    \"\"\"\nBINDINGS = [\n(\"q\", \"quit\", \"Quit\"),\n]\ndef __init__(self, *args, path: str, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.universal_path = path\ndef compose(self) -&gt; ComposeResult:\nyield Header()\nself.directory_tree = UniversalDirectoryTree(path=self.universal_path)\nself.file_content = Static()\nyield Horizontal(self.directory_tree, VerticalScroll(self.file_content))\nyield Footer()\n@on(UniversalDirectoryTree.FileSelected)\ndef handle_file_selected(\nself, message: UniversalDirectoryTree.FileSelected\n) -&gt; None:\n\"\"\"\n        Do something with the selected file.\n        Objects returned by the FileSelected event are upath.UPath objects and\n        they are compatible with the familiar pathlib.Path API built into Python.\n        \"\"\"\nselected_file_path = message.path\nfile_content = selected_file_path.read_text(errors=\"replace\")\nlexer = Syntax.guess_lexer(path=str(selected_file_path))\ncode = Syntax(code=file_content, lexer=lexer)\nself.file_content.update(code)\n</code></pre> <p>Run the above app in your terminal:</p> <pre><code>python -m textual_universal_directorytree github://juftin:textual-universal-directorytree@main/\n</code></pre>"},{"location":"#filesystems-supported","title":"Filesystems Supported","text":"<p><code>textual-universal-directorytree</code> leverages fsspec and universal_pathlib to enable compatibility with local and remote filesystems.</p> <p>In some cases you need to install a filesystem-specific library to enable compatibility with that filesystem. For example, to enable compatibility with AWS S3 you must install s3fs which is an <code>fsspec</code> implementation for S3.</p> <p>The following filesystems are known to be supported by <code>textual-universal-directorytree</code>, but it's possible that others filesystems are supported as well and just haven't been tested. If you find a filesystem that works, please open an issue.</p> File System Format Optional Dependencies Local <code>path/to/file</code> None Local <code>file://path/to/file</code> None AWS S3 <code>s3://bucket/path</code> s3fs AWS S3 <code>s3a://bucket/path</code> s3fs Google GCS <code>gs://bucket/path</code> gcsfs Azure Data Lake <code>adl://bucket/path</code> adlfs Azure Blob <code>abfs://bucket/path</code> adlfs Azure Blob <code>az://bucket/path</code> adlfs GitHub <code>github://owner:repo@branch</code> requests GitHub <code>github://owner:repo@branch/path</code> requests SSH <code>ssh://user@host:port/path</code> paramiko SFTP <code>sftp://user@host:port/path</code> paramiko"},{"location":"#license","title":"License","text":"<p><code>textual-universal-directorytree</code> is distributed under the terms of the MIT license.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#quickstart","title":"Quickstart","text":"<pre><code>pipx install pre-commit\npipx install hatch\npre-commit install\nhatch env create\nhatch shell\n</code></pre>"},{"location":"contributing/#tools","title":"Tools","text":"<p>This project makes use of a couple tools to streamline the development process: pre-commit and hatch.</p>"},{"location":"contributing/#pre-commit","title":"pre-commit","text":"<p>pre-commit is a tool to manage git-hooks scripts, which are useful for identifying simple issues before submission to code review.</p> <pre><code>pipx install pre-commit\npre-commit install\n</code></pre> <p>To use pre-commit, you must first install it. pipx is preferred, but you can also install with <code>pip</code>. Once pre-commit is installed, run <code>pre-commit install</code> to install the git-hooks scripts into the local repository. Done, now pre-commit will run automatically on git commit. To run it manually on your changed files run <code>pre-commit run</code> on your command line.</p>"},{"location":"contributing/#hatch","title":"hatch","text":"<p>hatch is a tool to manage the packaging and distribution of Python packages. It also used to manage the virtual environment for the project and running common scripts.</p> <pre><code>pipx install hatch\nhatch env create\nhatch run test\n</code></pre>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Releases for this project are handled entirely by CI/CD via Pull requests being merged into the <code>main</code> branch. Contributions follow the gitmoji standards with conventional commits, orchestration is handled by the semantic-release tool.</p> <p>While you can denote other changes on your commit messages with gitmoji, the following commit message emoji prefixes are the only ones to trigger new releases:</p> Emoji Shortcode Description Semver \ud83d\udca5 :boom: Introduce breaking changes. Major \u2728 :sparkles: Introduce new features. Minor \ud83d\udc1b :bug: Fix a bug. Patch \ud83d\ude91 :ambulance: Critical hotfix. Patch \ud83d\udd12 :lock: Fix security issues. Patch <p>Most features can be squash merged into a single commit. If you're working on a feature, your commit message might look like:</p> <pre><code>\u2728 New Feature Description\n</code></pre> <p>Bug fix commits would look like this:</p> <pre><code>\ud83d\udc1b Bug Fix Description\n</code></pre>"},{"location":"contributing/#scripts","title":"Scripts","text":"<p>All common scripts for this repository are managed by hatch.</p> <pre><code>hatch run &lt;script&gt;\n</code></pre> Script Script Description <code>format</code> Code Formatting black and ruff <code>lint</code> Code Linting black and ruff <code>check</code> Type Checking with mypy <code>test</code> Unit Testing with pytest <code>all</code> Run multiple scripts: <code>format</code>, <code>lint</code>, <code>check</code>, <code>test</code> <code>docs-serve</code> Documentation Serving MkDocs and mkdocs-material <code>requirements</code> Lock File Updates with pip-tools"},{"location":"contributing/#dependencies","title":"Dependencies","text":"<p>Dependencies are managed by pip-tools / pip-compile. After updating dependencies in the <code>pyproject.toml</code> file, run the following to update the underlying <code>requirements.txt</code> files:</p> <pre><code>hatch run requirements\n</code></pre>"}]}